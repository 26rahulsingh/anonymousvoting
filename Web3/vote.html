<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="Open Vote Network on Ethereum">
    <meta name="author" content="Paddy">
    <title>Voting Page</title>
    <!-- Bootstrap core CSS
    <link href="css/bootstrap.min.css" rel="stylesheet">-->
    <!-- Custom styles for this template
    <link href="starter-template.css" rel="stylesheet">-->
    <!-- Custom styles for this template -->
    <link href="css/steps.css" rel="stylesheet">
</head>

<body>
    <form id="msform">
        <!-- progressbar -->
        <ul id="progressbar">
            <li class="active">Voting Codes</li>
            <li>Unlock Address</li>
            <li>Register</li>
            <li>Compute</li>
            <li>Commit</li>
            <li>Cast</li>
            <li>Tally</li>
        </ul>
        <!-- The Steps -->
        <fieldset id="uploadfs">
            <p> Upload Voting Codes </p>
            <div id="dropdown1">
                <input id="uploadTrigger" name="next" class="action-button" value="Upload" type="button">
                <input id="done" class="hidden next" type="button">
                <input type='file' id='uploadFile' class="hidden" uploadtype='file' accept='text/plain' onchange='openFile(event);'>
            </div>
        </fieldset>
        <fieldset id="unlockfs">
            <div id="dropdown">
                <p>Address:</p>
                <select id='addrs' class="action-list">
                    <option value='0'>None</option>
                </select>

                <p>None of your Ethereum accounts are yet eligible to vote... Please contact Election Authority</p>
            </div>
        </fieldset>
        <fieldset id="registerfs">
            <div>
                <p id="registerby"></p>
                <br>
                <p id="question3"></p>
                <br>
                <div id = "registrationprogress"></div>
                <input disabled id="registerbutton" class="action-button" type="button" value="Register" onclick="register();">
                <br>
                <div hidden id = "submitvotingkey">Waiting for Ethereum to confirm your voting key.</div>
                <br>
            </div>

        </fieldset>

        <fieldset id="computefs">
            <div id="computediv">Waiting for Ethereum to compute all voter's special voting key.</div>
            <div>
          </div>

        </fieldset>

        <fieldset id="commitfs">
          <h2>Commit</h2>
            <p id="question2"></p>
            <br>
            <div id="vote">
                <button onclick="vote(1)" class="action-button">Yes</button>
                <button onclick="vote(0)" class="action-button">No</button>
            </div>
            <br>
            <p id="no_vote_waiting"></p>
        </fieldset>

        <fieldset id="votefs">
          <h2>Vote</h2>
            <br>
            <p id="question"></p>
            <br>
            <div id="do_vote">
                <button onclick="vote(1)" class="action-button">Yes</button>
                <button onclick="vote(0)" class="action-button">No</button>
            </div>
            <br>
            <p id="vote_waiting"></p>
        </fieldset>

        <fieldset id="tallyfs">
          <h2>Tally</h2>
          <br>
            <p id="question4"></p>
            <br>
            <div id="result">
            </div>
        </fieldset>

    </form>
    <!--<div id="infodiv1" class="notification rightTile">
    <h2>Events from Ethereum:</h2>
        <div class="insideArea">
            <p></p>
        </div>
    </div>-->

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- jQuery easing plugin -->
    <script src="http://thecodeplayer.com/uploads/js/jquery.easing.min.js" type="text/javascript"></script>
    <!-- <script src="js/bootstrap.min.js"></script>-->
    <script src="web3.min.js"></script>
    <script src="bignumber.min.js"></script>
    <script>
    /*
     * Web 3 credentials and connection
     */
    var web3;
    var password = "ilikelittlepaddy";
    var accounts_index;
    if (typeof web3 !== 'undefined') {
        web3 = new Web3(web3.currentProvider);
    } else {
        // set the provider you want from Web3.providers
        web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
    }

    // Anonymous Voting Contract
    var abi = [{"constant":true,"inputs":[],"name":"endComputationPhase","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"eligible","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[{"name":"xG","type":"uint256[2]"},{"name":"vG","type":"uint256[3]"},{"name":"r","type":"uint256"}],"name":"register","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[],"name":"computeTally","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"addressid","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[],"name":"totaleligible","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[],"name":"getVoter","outputs":[{"name":"_registeredkey","type":"uint256[2]"},{"name":"_reconstructedkey","type":"uint256[2]"},{"name":"_commitment","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[],"name":"endSignupPhase","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"a","type":"uint256"},{"name":"b","type":"uint256"}],"name":"submod","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[],"name":"commitmentphase","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"question","outputs":[{"name":"","type":"string"}],"type":"function"},{"constant":false,"inputs":[{"name":"addr","type":"address[]"}],"name":"setEligible","outputs":[],"type":"function"},{"constant":true,"inputs":[],"name":"finishSignupPhase","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"h","type":"bytes32"}],"name":"submitCommitment","outputs":[],"type":"function"},{"constant":true,"inputs":[],"name":"endCommitmentPhase","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[],"name":"finishRegistrationPhase","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"params","type":"uint256[4]"},{"name":"y","type":"uint256[2]"},{"name":"a1","type":"uint256[2]"},{"name":"b1","type":"uint256[2]"},{"name":"a2","type":"uint256[2]"},{"name":"b2","type":"uint256[2]"}],"name":"submitVote","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"totalcommitted","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"votecast","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"totalvoted","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"params","type":"uint256[4]"},{"name":"y","type":"uint256[2]"},{"name":"a1","type":"uint256[2]"},{"name":"b1","type":"uint256[2]"},{"name":"a2","type":"uint256[2]"},{"name":"b2","type":"uint256[2]"}],"name":"verify1outof2ZKP","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[],"name":"computeReconstructedPublicKeys","outputs":[],"type":"function"},{"constant":true,"inputs":[],"name":"endVotingPhase","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"commitment","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"registered","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[{"name":"_question","type":"string"},{"name":"enableCommitmentPhase","type":"bool"},{"name":"_finishSignupPhase","type":"uint256"},{"name":"_endSignupPhase","type":"uint256"},{"name":"_endComputationPhase","type":"uint256"},{"name":"_endCommitmentPhase","type":"uint256"},{"name":"_endVotingPhase","type":"uint256"},{"name":"gap","type":"uint256"}],"name":"beginSignUp","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"state","outputs":[{"name":"","type":"uint8"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"finaltally","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[],"name":"totalregistered","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[],"name":"reset","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"voters","outputs":[{"name":"addr","type":"address"},{"name":"commitment","type":"bytes32"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"addresses","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"xG","type":"uint256[2]"},{"name":"r","type":"uint256"},{"name":"vG","type":"uint256[3]"}],"name":"verifyZKP","outputs":[{"name":"","type":"bool"}],"type":"function"},{"inputs":[],"type":"constructor"}];
    var anonymousvoting = web3.eth.contract(abi);
    var anonymousvotingAddr = anonymousvoting.at("0xf70ce72acf09169c2610360e15862424ab2f43e0");

    // Local Crypto Contract
    var abi_crypto = [{"constant":false,"inputs":[{"name":"params","type":"uint256[4]"},{"name":"xG","type":"uint256[2]"},{"name":"yG","type":"uint256[2]"},{"name":"y","type":"uint256[2]"},{"name":"a1","type":"uint256[2]"},{"name":"b1","type":"uint256[2]"},{"name":"a2","type":"uint256[2]"},{"name":"b2","type":"uint256[2]"}],"name":"commitToVote","outputs":[{"name":"","type":"bytes32"}],"type":"function"},{"constant":false,"inputs":[{"name":"xG","type":"uint256[2]"},{"name":"yG","type":"uint256[2]"},{"name":"w","type":"uint256"},{"name":"r2","type":"uint256"},{"name":"d2","type":"uint256"},{"name":"x","type":"uint256"}],"name":"create1outof2ZKPNoVote","outputs":[{"name":"res","type":"uint256[10]"},{"name":"res2","type":"uint256[4]"}],"type":"function"},{"constant":false,"inputs":[{"name":"a","type":"uint256"},{"name":"b","type":"uint256"}],"name":"submod","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"x","type":"uint256"},{"name":"v","type":"uint256"},{"name":"xG","type":"uint256[2]"}],"name":"createZKP","outputs":[{"name":"res","type":"uint256[4]"}],"type":"function"},{"constant":false,"inputs":[{"name":"params","type":"uint256[4]"},{"name":"xG","type":"uint256[2]"},{"name":"yG","type":"uint256[2]"},{"name":"y","type":"uint256[2]"},{"name":"a1","type":"uint256[2]"},{"name":"b1","type":"uint256[2]"},{"name":"a2","type":"uint256[2]"},{"name":"b2","type":"uint256[2]"}],"name":"verify1outof2ZKP","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[{"name":"xG","type":"uint256[2]"},{"name":"yG","type":"uint256[2]"},{"name":"w","type":"uint256"},{"name":"r1","type":"uint256"},{"name":"d1","type":"uint256"},{"name":"x","type":"uint256"}],"name":"create1outof2ZKPYesVote","outputs":[{"name":"res","type":"uint256[10]"},{"name":"res2","type":"uint256[4]"}],"type":"function"},{"constant":false,"inputs":[{"name":"xG","type":"uint256[2]"},{"name":"r","type":"uint256"},{"name":"vG","type":"uint256[3]"}],"name":"verifyZKP","outputs":[{"name":"","type":"bool"}],"type":"function"},{"inputs":[],"type":"constructor"}];
    var crypto_contract = web3.eth.contract(abi_crypto);
    var cryptoAddr = crypto_contract.at("0x4e1969da1cd33afd3354e292a9ea009b7af4307a");

    // Fetch all the Ethereum addresses...
    function selectBox() {

        // Only run if user has not yet chosen an Ethereum address.
        if (!addressChosen) {
            var listEligible = "";
            var foundEligible = false;
            // Let user select one of their Ethereum addresses
            for (var i = 0; i < web3.eth.accounts.length; i++) {
                var tempaddr = web3.eth.accounts[i];
                if (anonymousvotingAddr.eligible(tempaddr)) {
                    foundEligible = true;
                    listEligible = listEligible + '<option value="' + i + '">' + tempaddr + '</option>';
                }
            }

            // Only create a drop-down box if we have found an address that is eligible to vote!
            if (foundEligible) {
                var selectbox = "<p>Address:</p><select id='addrs' class='action-list'>" + listEligible + "</select> <p>Password:</p> <input type='password' id='passwordf' value='ilikelittlepaddy' name='fname' class='action-text'> <input id='done2' class='hidden next' type='button'> <input type='button' class='action-button'  value = 'Login' onclick='unlock();'>";
                document.getElementById('dropdown').innerHTML = selectbox + '<p>Only eligible addresses appear in the list</p>';
            }


        }
    }

    function unlock() { //callback) {
        var _addr = $('#addrs').find(":selected").text();
        var _password = document.getElementById('passwordf').value;

        if (web3.personal.unlockAccount(_addr, _password)) {
            addressChosen = true;
            addr = _addr;
            password = _password;
            accounts_index = $("#addrs").val();
            controlTransition("#unlockfs", null);
            //document.getElementById('generalStatus').innerHTML = "You have selected the address " + addr;
        } else {
          alert("Password was not correct. Try again.");
        }
        currentState();
    }

    // Vote submits their voting key.
    function register() {

        if (!uploaded) {
            alert("Please upload your voting codes");
            return;
        }

        if (!addressChosen) {
            alert("Please unlock your Ethereum address");
            return;
        }

        if (state != 1) {
            alert("You can only register during the SIGNUP Phase ");
            return;
        }

        if (!anonymousvotingAddr.eligible(addr)) {
            alert("Your Ethereum Account is not eligible for this vote");
            return;
        }

        // We prove knowledge of the voting key
        var single_zkp = cryptoAddr.createZKP.call(x, v, xG, {
            from: web3.eth.accounts[accounts_index]
        });
        var vG = [single_zkp[1], single_zkp[2], single_zkp[3]];

        web3.personal.unlockAccount(addr, password);

        // Lets make sure the ZKP is valid!
        var verifyres = cryptoAddr.verifyZKP.call(xG, single_zkp[0], vG, {
            from: web3.eth.accounts[accounts_index]
        });
        if (!verifyres) {
            alert("Problem with voting codes");
            return;
        }

        // Submit voting key to the network
        if (anonymousvotingAddr.register.call(xG, vG, single_zkp[0], {
                from: web3.eth.accounts[accounts_index]
            })) {
            var res = anonymousvotingAddr.register.sendTransaction(xG, vG, single_zkp[0], {
                from: web3.eth.accounts[accounts_index],
                gas: 4200000
            });

            //TODO: DUPLICATED CODE FROM CURRENTSTATE. Needs its own function.
            document.getElementById('registerbutton').setAttribute("hidden",true);
            document.getElementById("registrationprogress").removeAttribute("hidden");
            document.getElementById("submitvotingkey").removeAttribute("hidden");
            txlist("Submit voting key: " + res);



        } else {
            alert("Registration failed... Problem could be your voting codes or that you have already registered");
        }
    }


    // User votes yes or no!
    function vote(choice) {

        if (!uploaded) {
            alert("Please upload your voting codes");
            return;
        }

        if (!addressChosen) {
            alert("Please unlock your Ethereum address");
            return;
        }

        // Lets make sure they are registered too...
        if (!anonymousvotingAddr.registered(addr)) {
            alert("You are not registered for this vote");
            return;
        }

        if (state == 0 || state == 1 || state == 2 || state == 5) {
            alert("You can only vote during the COMMITMENT or VOTE phase");
            return;
        }

        var choice_text;

        // Get xG and yG (only way to get values from a Struct)
        var voter = anonymousvotingAddr.getVoter.call({
            from: web3.eth.accounts[accounts_index]
        });
        var xG = [voter[0][0], voter[0][1]];
        var yG = [voter[1][0], voter[1][1]];

        if (choice == 1) {
            choice_text = "YES";
            result = cryptoAddr.create1outof2ZKPYesVote.call(xG, yG, w, r, d, x, {
                from: web3.eth.accounts[accounts_index]
            });
        } else {
            choice_text = "NO";
            result = cryptoAddr.create1outof2ZKPNoVote.call(xG, yG, w, r, d, x, {
                from: web3.eth.accounts[accounts_index]
            });
        }



        var y = [result[0][0], result[0][1]];
        var a1 = [result[0][2], result[0][3]];
        var b1 = [result[0][4], result[0][5]];
        var a2 = [result[0][6], result[0][7]];
        var b2 = [result[0][8], result[0][9]];

        var params = [result[1][0], result[1][1], result[1][2], result[1][3]];
        result = anonymousvotingAddr.verify1outof2ZKP.call(params, y, a1, b1, a2, b2, {
            from: web3.eth.accounts[accounts_index]
        });

        // Let's make sure the zero knowledge proof checked out...
        if (result) {

            var castvote = false;

            // We either send a commitment to the vote, or the vote itself!
            if (state == 3) {

                if (anonymousvotingAddr.commitmentphase()) {
                    castvote = true;
                } else if (confirm("You are voting " + choice_text + "... You will not be able to change your vote")) {
                    castvote = true;
                }

                if (castvote) {
                    web3.personal.unlockAccount(addr, password);

                    // Get us a hash commitment to the voter's zero knowledge proof
                    var h = cryptoAddr.commitToVote.call(params, xG, yG, y, a1, b1, a2, b2, {
                        from: web3.eth.accounts[accounts_index]
                    });

                    // Send commitment to Etherum!
                    result = anonymousvotingAddr.submitCommitment.sendTransaction(h, {
                        from: web3.eth.accounts[accounts_index],
                        gas: 4200000
                    });
                    document.getElementById('vote').innerHTML = 'You have sent (but not revealed) your vote... Waiting for Ethereum to confirm';
                    txlist("Submit commitment: " + result);
                }

            } else if (state == 4) {

                // No need to ask the user to confirm if they have already committed to it...
                if (anonymousvotingAddr.commitmentphase()) {
                    castvote = true;
                } else if (confirm("You are voting " + choice_text + ". You will not be able to change your vote.")) {
                    castvote = true;
                }

                // Should we broadcast the vote?
                if (castvote) {
                    web3.personal.unlockAccount(addr, password);
                    result = anonymousvotingAddr.submitVote.sendTransaction(params, y, a1, b1, a2, b2, {
                        from: web3.eth.accounts[accounts_index],
                        gas: 4200000
                    });
                    document.getElementById('do_vote').innerHTML = 'Vote has been submitted... Waiting for confirmation';
                    txlist("Submit vote: " + result);
                }
            }
        } else {
            alert("Vote was not computed successfully... Please check that you have uploaded the correct voting codes and unlocked the correct account");
        }
    }

    function whatIsQuestion() {
        document.getElementById('question').innerHTML = anonymousvotingAddr.question();
        document.getElementById('question2').innerHTML = anonymousvotingAddr.question();
        document.getElementById('question3').innerHTML = anonymousvotingAddr.question();
        document.getElementById('question4').innerHTML = anonymousvotingAddr.question();
    }

    whatIsQuestion();

    var temp=false;

    //[0] = x (private key)
    //[1] = xG (public key)
    //[2] = v (random nonce for zkp)
    //[3] = w (random nonce for 1outof2 zkp)
    //[4] = r (1 or 2, random nonce for 1outof2 zkp)
    //[5] = d (1 or 2, random nonce for 1outof2 zkp)
    // Read file that contains users drawOperationGasTable

    // x & xG is the voting key
    // v is the blinding factor for single zkp
    // w,r,d is required for 1 out of 2 zkp.
    // yG is recomputed public key - we get this from Ethereum
    var x;
    var xG;
    var v;
    var w;
    var r;
    var d;
    var addr;

    /*
     * State Variables. Make sure we only do these things ONCE.
     */
    var addressChosen = false; // User has selected their Ethereum Address
    var uploaded = false; // User has uploaded their voting codes
    var computedKey = false; // Ethereum has computed the keys
    var checkedCommit = false; // OPTIONAL: If user has commitment and in VOTE phase. Check if YES or NO.

    var openFile = function(event) {
        var input = event.target;

        var reader = new FileReader();
        reader.onload = function() {
            var text = reader.result.split("\n");

            var row = text[0].split(",");

            // We are expecting 7 numbers...
            if (row.length == 7) {
                uploaded = true;
                x = new BigNumber(row[0]);
                xG = [new BigNumber(row[1]), new BigNumber(row[2])];
                v = new BigNumber(row[3]);
                w = new BigNumber(row[4]);
                r = new BigNumber(row[5]);
                d = new BigNumber(row[6]);
                //  alert("Upload Succesful!");
                selectBox();
                nextSlide("#uploadfs","#unlockfs");
                //document.getElementById('generalStatus').innerHTML = "We have extracted your voting codes";

            } else {
                alert("Problem with uploaded file..." + row.length);
            }
        }

        reader.readAsText(input.files[0]);
    };

    var changedToCompute = false;
    var changedToCommit = false;
    var changedToVote = false;
    var changedToTally = false;
    function currentState() {

        if(!addressChosen) {
          return;
        }
        state = anonymousvotingAddr.state();

        whatIsQuestion();

        if (state == 0) {
            //document.getElementById('state').innerHTML = "SETUP: Election Authority is organising the election ";
            //$("#progressbar li").eq(0).addClass("active");

            document.getElementById('registerby').innerHTML = "Please wait.... Registration will begin soon.";

        } else if (state == 1) {

            // Have we submited the key yet?
            if(anonymousvotingAddr.registered(addr)) {
              document.getElementById('registerbutton').setAttribute("hidden",true);
              document.getElementById("registrationprogress").removeAttribute("hidden");
              document.getElementById("submitvotingkey").removeAttribute("hidden");

            } else {
              document.getElementById('registerbutton').removeAttribute("disabled");
            }

            var date = new Date();
            date.setTime(anonymousvotingAddr.finishSignupPhase() * 1000);
            document.getElementById('registerby').innerHTML = "Registration finishes at " + clockformat(date);
            /*document.getElementById('state').innerHTML = "SIGNUP: You can now sign up to the election if you are eligible ";
            var registerby = document.getElementById('registerby');
            var date = new Date();
            date.setTime(anonymousvotingAddr.endSignupPhase() * 1000);
            document.getElementById('endby').innerHTML = "Registration must be finished by  " + date;

            if (registerby != null) {
                var date = new Date();
                date.setTime(anonymousvotingAddr.finishSignupPhase() * 1000);
                document.getElementById('registerby').innerHTML = "Please register by " + date;
            }*/
            //$("#progressbar li").eq(1).addClass("active");
        } else if (state == 2) {
            if(!changedToCompute) {
              changedToCompute = true;
              controlTransition(id_current_fs, "#computefs");
            }
            /*document.getElementById('state').innerHTML = "COMPUTE: Ethereum is about to compute all voters special keys ";
            var date = new Date();
            date.setTime(anonymousvotingAddr.endComputationPhase() * 1000);
            document.getElementById('endby').innerHTML = "Phase must be finished before " + date;*/

        } else if (state == 3) {

          // Only run this transition once
          if(!changedToCommit) {
            changedToCommit = true;
            controlTransition(id_current_fs, "#commitfs");
          }
            /*document.getElementById('state').innerHTML = "COMMIT: Choose your vote... It will not be revealed until the VOTE phase";
            var date = new Date();
            date.setTime(anonymousvotingAddr.endCommitmentPhase() * 1000);
            document.getElementById('endby').innerHTML = "Phase must be finished before " + date;*/
            //$("#progressbar2 li").eq(3).addClass("active");

        } else if (state == 4) {

          if(!changedToVote) {
            changedToVote = true;
            controlTransition(id_current_fs, "#votefs");
          }

            //document.getElementById('state').innerHTML = "VOTE: Cast your vote! ";
            var date = new Date();
            date.setTime(anonymousvotingAddr.endVotingPhase() * 1000);

            if(anonymousvotingAddr.votecast(addr)) {
              checkVoteCast();
              checkStatistics();
              return;
            }
            //document.getElementById('endby').innerHTML = "Phase must be finished before " + date;

            // If user has submited a commitment... then check if it is yes or no
            // We can check this by re-computing the ZKP, and comparing the hashes.
            // Need to make sure that address has been chosen, voting codes uploaded, and registered.
            if (!checkedCommit && addressChosen && uploaded && anonymousvotingAddr.commitment(addr)) {

                // Lets not repeat this function again...
                checkedCommit = true;

                // Get xG and yG (only way to get values from a Struct)
                var voter = anonymousvotingAddr.getVoter.call({
                    from: web3.eth.accounts[accounts_index]
                });
                var xG = [voter[0][0], voter[0][1]];
                var yG = [voter[1][0], voter[1][1]];
                var h = voter[2];

                // Compute the 'YES' Zero Knowledge Proof...
                var result = cryptoAddr.create1outof2ZKPYesVote.call(xG, yG, w, r, d, x, {
                    from: web3.eth.accounts[accounts_index]
                });

                var y = [result[0][0], result[0][1]];
                var a1 = [result[0][2], result[0][3]];
                var b1 = [result[0][4], result[0][5]];
                var a2 = [result[0][6], result[0][7]];
                var b2 = [result[0][8], result[0][9]];
                var params = [result[1][0], result[1][1], result[1][2], result[1][3]];

                result = anonymousvotingAddr.verify1outof2ZKP.call(params, y, a1, b1, a2, b2, {
                    from: web3.eth.accounts[accounts_index]
                });

                // Make sure zkp is OK (indicates problem with voting codes)
                if (result) {

                    // Get us a hash commitment to the voter's zero knowledge proof
                    var _h = cryptoAddr.commitToVote.call(params, xG, yG, y, a1, b1, a2, b2, {
                        from: web3.eth.accounts[accounts_index]
                    });

                    // Check hash for this ZKP, and the hash commitment stored in Ethereum for this voter...
                    if (h == _h) {
                        document.getElementById('do_vote').innerHTML = "<button onclick='vote(1)' class='action-button'>Reveal Yes</button>";
                        return;
                    }
                } else {
                    alert("Something went wrong... Please check your voting codes");
                    return;
                }

                result = cryptoAddr.create1outof2ZKPNoVote.call(xG, yG, w, r, d, x, {
                    from: web3.eth.accounts[accounts_index]
                });
                y = [result[0][0], result[0][1]];
                a1 = [result[0][2], result[0][3]];
                b1 = [result[0][4], result[0][5]];
                a2 = [result[0][6], result[0][7]];
                b2 = [result[0][8], result[0][9]];
                params = [result[1][0], result[1][1], result[1][2], result[1][3]];

                result = anonymousvotingAddr.verify1outof2ZKP.call(params, y, a1, b1, a2, b2, {
                    from: web3.eth.accounts[accounts_index]
                });

                // Did we find a no vote?
                if (result) {
                    // Get us a hash commitment to the voter's zero knowledge proof
                    var _h = cryptoAddr.commitToVote.call(params, xG, yG, y, a1, b1, a2, b2, {
                        from: web3.eth.accounts[accounts_index]
                    });

                    if (h == _h) {
                        document.getElementById('do_vote').innerHTML = "<button onclick='vote(0)' class='action-button'>Reveal No</button>";
                        return;
                    }
                } else {
                    alert("Something went wrong. Please check your voting codes.");
                    return;
                }

                //document.getElementById('vote').innerHTML = "Possibly something wrong with the voting codes you uploaded... Try again";
            }


        } else if (state == 5) {
          if(!changedToTally) {
            changedToTally = true;;
            controlTransition(id_current_fs, "#tallyfs");
          }
            var yes = anonymousvotingAddr.finaltally(0);
            var total = anonymousvotingAddr.finaltally(1);
            var no = total - yes;
            document.getElementById('result').innerHTML = "Yes - " + yes + " No - " + no;
            //document.getElementById('endby').innerHTML = "We are finished!";
            checkVoteCast();

        } else {
            //document.getElementById('state').innerHTML = "Undocumented Phase: Something went wrong... ";
            alert("Undocumented Phase: Something went wrong... ");
        }

        // // Are we eligible to vote?
        // if (anonymousvotingAddr.eligible(addr)) {
        //     //document.getElementById('generalStatus').innerHTML += "You are eligible to vote... Address is " + addr;
        //     console.log("You are eligible to vote... Address is " + addr);
        // }



        checkVoteCast();
        checkStatistics();

    }

    function txlist(extra) {
        //document.getElementById('txlist').innerHTML = document.getElementById('txlist').innerHTML + "<br>" + extra;
    }

    function checkStatistics() {

      var eligible = anonymousvotingAddr.totaleligible();
      var registered = anonymousvotingAddr.totalregistered();
      var committed = anonymousvotingAddr.totalcommitted();
      var voted = anonymousvotingAddr.totalvoted();

      document.getElementById("registrationprogress").innerHTML = "Currently " + registered + "/" + eligible + " voters registered.";
      document.getElementById("no_vote_waiting").innerHTML = "Currently " + committed + "/" + registered + " voters have sealed, but not revealed their encrypted vote.";
      document.getElementById("vote_waiting").innerHTML = "Currently " + voted + "/" + registered + " votes have been cast.";
    }

    function checkVoteCast() {

        // Check if key has been submitted
        if (anonymousvotingAddr.registered(addr)) {
            document.getElementById('submitvotingkey').innerHTML = "Voting key has been accepted by Ethereum";
            //Check if vote has already been cast (or if a commitment has been accepted)
            if (anonymousvotingAddr.votecast(addr)) {
                document.getElementById('do_vote').innerHTML = "Vote has been cast";
            } else if (anonymousvotingAddr.commitment(addr) && state != 4) {
                document.getElementById('vote').innerHTML = "You have comitted (but not revealed) your vote";
            }
        }


    }

    setInterval("currentState()", 5000);
    currentState();

    // Control which window opens....
    function controlTransition(currentfs, nextfs) {

      // Prevent weird loop
      if(currentfs == nextfs) {
        return;
      }
      // Do we know where to go next?
      if(nextfs != null) {
          nextSlide(currentfs, nextfs);
      }

      // Nope.. jump to latest state.
      var state = anonymousvotingAddr.state();

      switch(state.toString("10")) {
        case "0":
        case "1":
           nextSlide(currentfs, "#registerfs");
           break;
        case "2":
           $("#progressbar li").eq($("fieldset").index($("#registerfs"))).addClass("active");
           nextSlide(currentfs, "#computefs");
           break;
        case "3":
           $("#progressbar li").eq($("fieldset").index($("#registerfs"))).addClass("active");
           $("#progressbar li").eq($("fieldset").index($("#computefs"))).addClass("active");
           nextSlide(currentfs, "#commitfs");
           break;
        case "4":
           $("#progressbar li").eq($("fieldset").index($("#registerfs"))).addClass("active");
           $("#progressbar li").eq($("fieldset").index($("#computefs"))).addClass("active");
           $("#progressbar li").eq($("fieldset").index($("#commitfs"))).addClass("active");
           nextSlide(currentfs, "#votefs");
           break;
        case "5":
           $("#progressbar li").eq($("fieldset").index($("#registerfs"))).addClass("active");
           $("#progressbar li").eq($("fieldset").index($("#computefs"))).addClass("active");
           $("#progressbar li").eq($("fieldset").index($("#commitfs"))).addClass("active");
           $("#progressbar li").eq($("fieldset").index($("#votefs"))).addClass("active");
           $("#progressbar li").eq($("fieldset").index($("#tallyfs"))).addClass("active");
           nextSlide(currentfs, "#tallyfs");
           break;
        default:
          break;
      }
    }

    // Easy to read clock time format.
    function clockformat(date) {

       var toString = date.getHours() + ":" + date.getMinutes() + ", "

       toString = toString + (date.getMonth() + 1) + "/" + date.getDate() + "/" + date.getFullYear();

       return toString;
    }
    </script>



    <!-- This Scripts are for the theme! Added by Ehsan, 29/09/2016-->
    <script>
    /* FOR THE FIELD SET STEPPING */
    var current_fs, next_fs; //fieldsets
    var id_current_fs;
    var left, opacity, scale; //fieldset properties which we will animate
    var animating; //flag to prevent quick multi-click glitches
    function nextSlide(current_id, next_id) {
        if (animating) return false;
        animating = true;

        current_fs = $(current_id);
        next_fs = $(next_id);
        id_current_fs = next_id; // Added by paddy to get string id

        //activate next step on progressbar using the index of next_fs
        $("#progressbar li").eq($("fieldset").index(next_fs)).addClass("active");

        //show the next fieldset
        next_fs.show();
        //hide the current fieldset with style
        current_fs.animate({
            opacity: 0
        }, {
            step: function(now, mx) {
                //as the opacity of current_fs reduces to 0 - stored in "now"
                //1. scale current_fs down to 80%
                scale = 1 - (1 - now) * 0.2;
                //2. bring next_fs from the right(50%)
                left = (now * 50) + "%";
                //3. increase opacity of next_fs to 1 as it moves in
                opacity = 1 - now;
                current_fs.css({
                    'transform': 'scale(' + scale + ')'
                });
                next_fs.css({
                    'left': left,
                    'opacity': opacity
                });
            },
            duration: 800,
            complete: function() {
                current_fs.hide();
                animating = false;
            },
            //this comes from the custom easing plugin
            easing: 'easeInOutBack'
        });
    }

    $(".submit").click(function() {
        return false;
    });
    /* FOR THE OTHER TWEAKS */

    $("#uploadTrigger").click(function() {
        //console.log("Clicked2");
        $("#uploadFile").click();
    });

    //$("#triggerNext1").click(function() {
    //  console.log("Clicked2");
    // $("#done2").click();
    //});
    </script>
    <!-- Until Here! -->
</body>

</html>
