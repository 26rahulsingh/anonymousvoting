<html>
<head>
  <title>Voting Page</title>
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js">

</head>

<body>

  <div class="header">
    <h3>Voting Homepage</h3>
  </div>
  <div id="state">
  </div>
  <div id="upload">
     <p>Please open the file with your voting codes</p>
     <input type='file' accept='text/plain' onchange='openFile(event)'>
  </div>
  <div id="dropdown">
  </div>
  <div id="eligible">
  <p>Is the currently selected address eligible to vote? </p>
  <button onclick="eligible()">Eligible</button>
  <p id="iseligible"></p>
  </div>
  <div id="submitvotingkey">
  <p>Submit Voting Key and Register for the vote!</p>
  <button onclick="register()">Submit Voting Key</button>
  </div>
  <div id="vote">
  <p id="question"></p>
  <button onclick="vote(1)">Vote Yes</button>
  <button onclick="vote(0)">Vote No</button>
  </div>
  <div id="txlist">
    <p>Transaction List:</p>
  </div>
  <div id="infodiv">
    <p>Events from Ethereum:</p>
  </div>

</body>

<script src="web3.min.js"></script>
<script src="bignumber.min.js"></script>
<script src ="https://code.jquery.com/jquery-3.1.0.slim.min.js"></script>

<script>

var web3;
var password = "ilikelittlepaddy";
var accounts_index;
if (typeof web3 !== 'undefined') {
  web3 = new Web3(web3.currentProvider);
} else {
  // set the provider you want from Web3.providers
  web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
}

var abi = [{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"eligible","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[{"name":"xG","type":"uint256[2]"},{"name":"vG","type":"uint256[3]"},{"name":"r","type":"uint256"}],"name":"register","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[],"name":"computeTally","outputs":[{"name":"res","type":"uint256[2]"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"addressid","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"votecast","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[{"name":"w","type":"uint256"},{"name":"i","type":"uint256"},{"name":"r1","type":"uint256"},{"name":"d1","type":"uint256"},{"name":"x","type":"uint256"}],"name":"create1outof2ZKPYesVote","outputs":[{"name":"res","type":"uint256[10]"},{"name":"res2","type":"uint256[4]"}],"type":"function"},{"constant":false,"inputs":[{"name":"a","type":"uint256"},{"name":"b","type":"uint256"}],"name":"submod","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[],"name":"question","outputs":[{"name":"","type":"string"}],"type":"function"},{"constant":false,"inputs":[{"name":"addr","type":"address[]"}],"name":"setEligible","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"},{"name":"","type":"uint256"}],"name":"registeredkey","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[],"name":"finishRegistrationPhase","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"params","type":"uint256[4]"},{"name":"y","type":"uint256[2]"},{"name":"a1","type":"uint256[2]"},{"name":"b1","type":"uint256[2]"},{"name":"a2","type":"uint256[2]"},{"name":"b2","type":"uint256[2]"}],"name":"submitVote","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"timer","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"x","type":"uint256"},{"name":"v","type":"uint256"},{"name":"xG","type":"uint256[2]"}],"name":"createZKP","outputs":[{"name":"res","type":"uint256[4]"}],"type":"function"},{"constant":false,"inputs":[],"name":"computeReconstructedPublicKeys","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"registered","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"},{"name":"","type":"uint256"}],"name":"reconstructed","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[],"name":"state","outputs":[{"name":"","type":"uint8"}],"type":"function"},{"constant":false,"inputs":[{"name":"params","type":"uint256[4]"},{"name":"i","type":"uint256"},{"name":"y","type":"uint256[2]"},{"name":"a1","type":"uint256[2]"},{"name":"b1","type":"uint256[2]"},{"name":"a2","type":"uint256[2]"},{"name":"b2","type":"uint256[2]"}],"name":"verify1outof2ZKP","outputs":[{"name":"","type":"bool"}],"type":"function"},{"constant":false,"inputs":[{"name":"time","type":"uint256"},{"name":"_question","type":"string"}],"name":"beginSignUp","outputs":[],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"},{"name":"","type":"uint256"}],"name":"votes","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[],"name":"reset","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"w","type":"uint256"},{"name":"i","type":"uint256"},{"name":"r2","type":"uint256"},{"name":"d2","type":"uint256"},{"name":"x","type":"uint256"}],"name":"create1outof2ZKPNoVote","outputs":[{"name":"res","type":"uint256[10]"},{"name":"res2","type":"uint256[4]"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"addresses","outputs":[{"name":"","type":"address"}],"type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"type":"function"},{"constant":false,"inputs":[{"name":"xG","type":"uint256[2]"},{"name":"r","type":"uint256"},{"name":"vG","type":"uint256[3]"}],"name":"verifyZKP","outputs":[{"name":"","type":"bool"}],"type":"function"},{"inputs":[],"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"addr","type":"address"}],"name":"Eligible","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"message","type":"string"},{"indexed":false,"name":"currentblock","type":"uint256"},{"indexed":false,"name":"futureblock","type":"uint256"}],"name":"StartTimer","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"addr","type":"address"},{"indexed":false,"name":"res","type":"bool"},{"indexed":false,"name":"counter","type":"uint256"}],"name":"Registered","type":"event"},{"anonymous":false,"inputs":[],"name":"RegistrationFinished","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"x","type":"uint256"},{"indexed":false,"name":"y","type":"uint256"},{"indexed":false,"name":"counter","type":"uint256"}],"name":"ReconstructedKey","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"addr","type":"address"},{"indexed":false,"name":"res","type":"bool"},{"indexed":false,"name":"counter","type":"uint256"}],"name":"RegisterVote","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"tally","type":"uint256"},{"indexed":false,"name":"counter","type":"uint256"}],"name":"Tally","type":"event"},{"anonymous":false,"inputs":[],"name":"Reset","type":"event"}];
var anonymousvoting = web3.eth.contract(abi);
var anonymousvotingAddr = anonymousvoting.at("0x9528622a884ee4731ac5a3ff8b5c00001ea95bfa");
var selectbox = "<p>Address:</p><select id='addrs'>";

// Let user select one of their Ethereum addresses
for(var i=0; i<web3.eth.accounts.length; i++) {
  selectbox = selectbox + '<option value="' + i + '">' + web3.eth.accounts[i] + '</option>';
}

selectbox = selectbox + "</select> <p>Password:</p> <input type='password' id='passwordf' value='ilikelittlepaddy' name='fname'><button onclick='unlock()'>Unlock</button>";
document.getElementById('dropdown').innerHTML = selectbox;

function unlock() {
  var _addr = $('#addrs').find(":selected").text();
  var _password = document.getElementById('passwordf').value;

  if(web3.personal.unlockAccount(_addr,_password)) {
    addressChosen = true;
    addr = _addr;
    password = _password;
    accounts_index = $( "#addrs" ).val();
    document.getElementById('dropdown').innerHTML = "You have selected the address " + addr;
  }

  currentState();
}

// Check that the user is eligible to vote
function eligible() {
  var tempaddr;

  // User might not have chosen their address yet...
  if(addressChosen) {
    tempaddr = addr;
  } else {
    tempaddr = $('#addrs').find(":selected").text();
  }

  if(anonymousvotingAddr.eligible(addr)) {
    document.getElementById('iseligible').innerHTML = "Yes! This address is eligible to vote!";
  } else {
    alert("You are not yet eligible");
  }
}

function register() {

  if(!addressChosen) {
    alert("Please choose an address.");
    return;
  }

  if(!uploaded) {
    alert("Please upload your voting codes.");
    return;
  }

  if(state != 1) {
    alert("You can only vote during the SIGNUP Phase. ");
    return;
  }

  var zkp = anonymousvotingAddr.createZKP.call(x, v, xG);
  var vG = [zkp[1], zkp[2], zkp[3]];
  web3.personal.unlockAccount(addr,password);
  var res = anonymousvotingAddr.register.sendTransaction(xG, vG, zkp[0], {from:web3.eth.accounts[accounts_index], gas: 4200000});
  alert("Sending voting key. ");
  document.getElementById('submitvotingkey').innerHTML = "Voting key submitted. Waiting on Ethereum to confirm.";
  txlist("Submit voting key: " + res);

}

function vote(choice) {

  if(!addressChosen) {
    alert("Please choose an address.");
    return;
  }

  if(!uploaded) {
    alert("Please upload your voting codes.");
    return;
  }

  if(state != 3) {
    alert("You can only submit your codes during the VOTEPHASE.");
    return;
  }
  // Has user unlocked an Ethereum Address?
  if(addressChosen && uploaded) {

    // Does the user have a reconstructed key?
    if(anonymousvotingAddr.registered(addr)) {
        var ind = anonymousvotingAddr.addressid(addr); // What is our index for the vote?

        // Create vote...
        if(choice == 1) {
          alert("Voting Yes");
          result = anonymousvotingAddr.create1outof2ZKPYesVote.call(w,ind,r,d,x);
        } else {
          alert("Voting No");
          result = anonymousvotingAddr.create1outof2ZKPNoVote.call(w,ind,r,d,x);
        }

        var y = [result[0][0], result[0][1]];
        var a1 = [result[0][2], result[0][3]];
        var b1 = [result[0][4], result[0][5]];
        var a2 = [result[0][6], result[0][7]];
        var b2 = [result[0][8], result[0][9]];

        var params = [result[1][0], result[1][1], result[1][2], result[1][3]];
        result = anonymousvotingAddr.verify1outof2ZKP.call(params, ind, y, a1, b1, a2, b2);
        // alert("Does the 1 out of 2 ZKP Verify: "  + result);

        if(result) {
          alert("Sending vote");
          web3.personal.unlockAccount(addr,password);
          result = anonymousvotingAddr.submitVote.sendTransaction(params, y, a1, b1, a2, b2, {from:web3.eth.accounts[accounts_index], gas: 4200000});
          document.getElementById('vote').innerHTML = 'Vote has been submitted. Waiting for confirmation.';
          txlist("Submit vote: " + result);
        } else {
          alert("Not sending vote");
        }
    } else {
      alert("No reconstructed key found in Ethereum... might not be ready yet");
    }
  } else {
    alert("You either need to 1) Choose an Ethereum address, 2) Ensure the address is eligible, 3) Upload your voting codes");
  }
}

function whatIsQuestion() {
  document.getElementById('question').innerHTML = anonymousvotingAddr.question();
}

whatIsQuestion();

//[0] = x (private key)
//[1] = xG (public key)
//[2] = v (random nonce for zkp)
//[3] = w (random nonce for 1outof2 zkp)
//[4] = r (1 or 2, random nonce for 1outof2 zkp)
//[5] = d (1 or 2, random nonce for 1outof2 zkp)
// Read file that contains users drawOperationGasTable

// x & xG is the voting key
// v is the blinding factor for single zkp
// w,r,d is required for 1 out of 2 zkp.
// yG is recomputed public key - we get this from Ethereum
var x;
var xG;
var v;
var w;
var r;
var d;
var addr;

// Keep track of what user has done...
var addressChosen = false;
var uploaded = false;
var computedKey = false;

var openFile = function(event) {
  var input = event.target;

  var reader = new FileReader();
  reader.onload = function(){
    var text = reader.result.split("\n");

    var row = text[0].split(",");

    // We are expecting 7 numbers...
    if(row.length == 7) {
       uploaded = true;
       x = new BigNumber(row[0]);
       xG = [new BigNumber(row[1]), new BigNumber(row[2])];
       v = new BigNumber(row[3]);
       w = new BigNumber(row[4]);
       r = new BigNumber(row[5]);
       d = new BigNumber(row[6]);
       alert("Upload Succesful!");
       document.getElementById('upload').innerHTML = "We have extracted your voting codes.";

    } else {
      alert("Problem with uploaded file..." + row.length);
    }
  }

  reader.readAsText(input.files[0]);
};

function currentState() {
  state = anonymousvotingAddr.state();

  if(state == 0) {
    document.getElementById('state').innerHTML = "SETUP Phase";
  } else if(state == 1) {
    document.getElementById('state').innerHTML = "SIGNUP Phase";
  } else if(state == 2) {
    document.getElementById('state').innerHTML = "COMPUTE Phase";
  } else if(state == 3) {
    document.getElementById('state').innerHTML = "VOTEPHASE Phase";
  } else if(state == 4) {
    document.getElementById('state').innerHTML = "FINISH Phase";
  } else {
    document.getElementById('state').innerHTML = "Undocumented Phase...";
  }

  // Are we eligible to vote?
  if(anonymousvotingAddr.eligible(addr)) {
    document.getElementById('eligible').innerHTML = "You are eligible to vote";
  }
  // Check if key has been submitted
  if(anonymousvotingAddr.registered(addr)) {
     document.getElementById('submitvotingkey').innerHTML = "Voting key has been accepted by Ethereum";

     //Check if vote has already been cast
     var voter_index = anonymousvotingAddr.addressid(addr);
     if(anonymousvotingAddr.votecast(voter_index)) {
       document.getElementById('vote').innerHTML = "Vote has been cast.";
     }
  }

  whatIsQuestion();

}

/*
* Catch events in real-time and update the site with the voting progress..
*/
var allevents = anonymousvotingAddr.allEvents({}, '', function(error, result){
 if (!error){

   // Tell the admin if the address became eligible...
   if(result.event === "Eligible") {
      var receipt = web3.eth.getTransactionReceipt(result.transactionHash);

      if(result.args.addr == addr) {
        append(result.event + "," + result.args.addr);
      }
   }

   // Voting phase has begun!
   if(result.event === "StartTimer") {
      append(result.event + "," + result.args.message + "," + result.args.currentblock + "," + result.args.futureblock);
   }

   // Voting key has been submitted.
   if(result.event === "Registered") {
     if(result.args.addr == addr) {
       append(result.event + "," + result.args.addr + "," + result.args.res + "," + result.args.counter);
     }
   }

   // Registration Phase has Finished!
   if(result.event === "RegistrationFinished") {
      append(result.event);
   }

   // Compute the reconstructed keys
   if(result.event === "ReconstructedKey") {
      if(anonymousvotingAddr.addressid(addr).equals(result.args.counter)) {
        append(result.event + "," + result.args.x.toString(10) + "," + result.args.y.toString(10) + "," + result.args.counter);
      }
   }

   // Vote has been cast.
   if(result.event === "RegisterVote") {
     if(result.args.addr == addr) {
       append(result.event + "," + result.args.addr + "," + result.args.res + "," + result.args.counter);
     }
   }

   // Final tally... tell us gas usage as well.
   if(result.event === "Tally") {
     append(result.event + " - Yes Votes: " + result.args.tally.toString(10) + " and Total Votes Counted: " + result.args.counter.toString(10));
   }

   // Always update current state.
   currentState();
 }
});

function append(extra) {
    var div = document.getElementById('infodiv');
    div.innerHTML = div.innerHTML + "<br>" + "<p>" + extra + "</p>";
}

function txlist(extra) {
    document.getElementById('txlist').innerHTML = document.getElementById('txlist').innerHTML + "<br>" + extra;
}

setInterval("currentState()", 1000);
currentState();

</script>
